package cve_query

import (
	"enigma/server/src/common/defs"
	cve_search "enigma/server/src/engine/cve-search"
	"github.com/labstack/echo/v4"
	"net/http"
	"strconv"
)

func getCVEHandlerV1(c echo.Context) error {
	cveId := c.QueryParam("id")
	if len(cveId) == 0 {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "cveId should be provided for this endpoint",
			Payload: nil,
		})
	}
	cveRecord, err := cve_search.GetCVERecordFromID(G, cveId)
	if err == nil {
		return c.JSON(http.StatusOK, defs.SuccessResponse(cveRecord))
	} else {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "failed to get cve record",
			Payload: nil,
		})
	}
}

func getCWEAllHandler(c echo.Context) error {
	cwelist, err := cve_search.GetCWElist(G)
	if err == nil {
		return c.JSON(http.StatusOK, defs.SuccessResponse(cwelist))
	} else {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "failed to get cwelist",
			Payload: nil,
		})
	}
}

func getCapecItemHandler(c echo.Context) error {
	cweId := c.QueryParam("id")
	id, err := strconv.Atoi(cweId)
	if len(cweId) == 0 || err != nil || id < 0 {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "cweId should be provided for this endpoint",
			Payload: nil,
		})
	}
	cwelist, err := cve_search.GetCapecForId(G, id)
	if err == nil {
		return c.JSON(http.StatusOK, defs.SuccessResponse(cwelist))
	} else {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "failed to get capec",
			Payload: nil,
		})
	}
}

func getCirclCurrentHandler(c echo.Context) error {
	circlInfo, err := cve_search.GetCirclInfo(G)
	if err == nil {
		return c.JSON(http.StatusOK, defs.SuccessResponse(circlInfo))
	} else {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "failed to get circlInfo",
			Payload: nil,
		})
	}
}

func getCapecCountHandler(c echo.Context) error {
	capecCount, err := cve_search.GetCapecCountInDB(G)
	if err == nil {
		return c.JSON(http.StatusOK, defs.SuccessResponse(capecCount))
	} else {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "failed to get capec count",
			Payload: nil,
		})
	}
}

func ctlAnalyzeCapecInfoHandler(c echo.Context) error {
	capecAnalyzeInfo, err := getCapecAnalyzeInfo(G)

	if err == nil {
		return c.JSON(http.StatusOK, defs.SuccessResponse(capecAnalyzeInfo))
	} else {
		return c.JSON(http.StatusOK, defs.HttpResponse{
			Code:    1,
			Msg:     "failed to get capec analyze info",
			Payload: nil,
		})
	}
}

func getCapecAnalyzeInfo(G *defs.Global) (defs.CapecAnalyzeInfo, error){
	var analyzeInfo defs.CapecAnalyzeInfo

	circlInfo, err := cve_search.GetCirclInfo(G)
	if err != nil {
		return analyzeInfo, err
	}
	inDBSize, err := cve_search.GetCapecCountInDB(G)
	if err != nil {
		return analyzeInfo, err
	}

	analyzeInfo.FullSize =    circlInfo.Capec.Size
	analyzeInfo.CurrentSize = inDBSize

	return G.Modules.Capec.AnalyzeInfo, nil
}